;; Frame operations
(define (empty-frame)
	(list)
)

(define (update frame var val)
	(cons (cons var val) frame)
)

(define (lookup var frame)
	(assoc var frame)
)

;; environment operations
(define (make-env)
	(list (empty-frame))
)

(define (extend-env env)
	(cons (empty-frame) env)
	)

	(define (define-var env var val)
	(if (null? env)
		#f
		(set-car! env (update (car env) var val))
	)
	env
)

(define (lookup-var var env)
	(if (null? env)
		#f
		(let ((found (lookup var (car env))))
			(if (pair? found)
				found
				(lookup-var var (cdr env))
			)
		)
	)
)

;; lambda closure operations
;; lambda closure has *lambda symbols,
;; parameters and function body code and environment
(define (make-closure env params body)
	(cons '*lambda* (cons env (cons params body)))
)

(define (data-closure? data)
	(and (pair? data) (equal? (car data) '*lambda*))
)

(define closure-env cadr)
(define closure-params caddr)
(define closure-body cdddr)

;; primitive operations with specified arity and function
(define (make-primitive arity fun)
	(list '*primitive* arity fun)
)

(define (data-primitive? data)
	(and (pair? data) (equal? (car data) '*primitive*))
)

(define primitive-arity cadr)
(define primitive-fun caddr)

;; function to print data
(define (print-data data)
	(cond
		((data-closure? data) (display "#<closure>"))
		((data-primitive? data) (display "#<primitive>"))
		((equal? data '*unspecified*) (display "#<unspecified>"))
		((equal? data '*error*) (display "#<error>"))
		((equal? data '*exit*))
		(else (write data))
	)
)

;; evaluation
(define (base-eval env exp)
	(cond
	((eof-object? exp) (cons env '*exit*))
	((constant? exp) (cons env exp))
	((symbol? exp) (var-eval env exp))
	((not (pair? exp)) (eval-error env 'unknown-data exp))
	((equal? (car exp) 'exit) (cons env '*exit*))
	((equal? (car exp) 'define) (def-eval env exp))
	((equal? (car exp) 'let) (let-eval env exp))
	((equal? (car exp) 'lambda) (lambda-eval env exp))
	((equal? (car exp) 'if) (if-eval env exp))
	((equal? (car exp) 'quote) (quote-eval env exp))
	((equal? (car exp) 'let*) (let*-eval env exp))
	((equal? (car exp) 'cond) (cond-eval env exp))
	((equal? (car exp) 'list) (list-eval env exp))
	((equal? (car exp) 'begin) (begin-eval env exp))
	(else (app-eval env exp))
)
)

(define (constant? exp)
	(or (boolean? exp) (number? exp) (string? exp))
)


(define (eval-error env type exp)
	(display "ERROR: ")
	(write type)
	(display ": ")
	(print-data exp)
	(newline)
	(cons env '*error*)
)

;; always returns #t
(define (correct-syntax? type exp) #t)

(define (let->app exp)
	(let ((decl (cadr exp)) (body (cddr exp)))
	(cons (cons 'lambda (cons (map car decl) body))
	(map cadr decl)))
)

(define (let-eval env exp)
	(if (correct-syntax? 'let exp)
		(base-eval env (let->app exp))
		(eval-error env 'syntax-error exp)
	)
)

(define (define-var-multiple* env vars vals)
	(if (null? vars)
		env
		(define-var-multiple* (define-var env (car vars) (cdr (base-eval env (car vals)))) (cdr vars) (cdr vals)))
)

(define (let*-eval env exp)
	(let* ((tmp-env (extend-env env))
		(exenv (define-var-multiple* tmp-env (map car (cadr exp)) (map cadr (cadr exp)))))
		(cons env (last (map-base-eval exenv (cddr exp)) )))
)

(define (def-eval env exp)
	(if (correct-syntax? 'define exp)
		(if (pair? (cadr exp))
			;; 略記
			(let* ((var (caadr exp))
				(params (cdadr exp))
				(body (cddr exp))
				(lambda-exp (cons 'lambda (cons params body))))
				(let ((res (base-eval env lambda-exp)))
				(cons (define-var env var (cdr res)) var)))
			;; 通常
			(let* ((var (cadr exp))
				(res (base-eval env (caddr exp)))
				(env (car res))
				(val (cdr res)))
			(cons (define-var env var val) var))
		)
		(eval-error env 'syntax-error exp)
	)
)

(define (var-eval env exp)
	(let ((found (lookup-var exp env)))
	(if (pair? found)
		(cons env (cdr found))
		(eval-error env 'variable-not-found exp)
	))
)

(define (lambda-eval env exp)
	(if (correct-syntax? 'lambda exp)
		(cons env (make-closure env (cadr exp) (cddr exp)))
		(eval-error env 'syntax-error exp)
	)
)

(define (define-var-multiple env vars vals)
	(if (null? vars)
		env
		(define-var-multiple (define-var env (car vars) (car vals)) (cdr vars) (cdr vals))
	)
)

(define (last l)
	(if (null? (cdr l)) (car l) (last (cdr l)))
)

(define (base-apply env fun args)
	(cond 
		((data-closure? fun)
		(if (= (length (closure-params fun)) (length args))
			(let* ((tmp-env (extend-env (closure-env fun)))
				(exenv (define-var-multiple tmp-env (closure-params fun) args)))
				(cons env (last (cdr (map-base-eval exenv (closure-body fun))))))
				(eval-error env 'wrong-number-of-args fun)))
		((data-primitive? fun)
		(if (or (not (number? (primitive-arity fun))) (= (primitive-arity fun) (length args)))
			((primitive-fun fun) env args)
			(eval-error env 'wrong-number-of-args fun)
		))
		(else
			(eval-error env 'non-function fun)
		)
	)
)

(define (map-base-eval env el)
	(cons env (map (lambda (exp) (cdr (base-eval env exp))) el))
)

(define (app-eval env exp)
	(if (correct-syntax? 'app exp)
		(let* ((l (map-base-eval env exp))
		(env (car l))
		(fun (cadr l))
		(args (cddr l)))
		(base-apply env fun args))
		(eval-error env 'synatx-error exp)
	)
)

(define (if-eval env exp)
	(if (correct-syntax? 'if exp)
		(let* ((cond-res (base-eval env (cadr exp)))
			(ok (cdr cond-res)))
		(if ok
			(base-eval env (caddr exp))
			(base-eval env (if (not (null? (cdddr exp)))
				(cadddr exp)
				#f
			))
		))
		(eval-error env 'synatx-error exp)
	)
)

(define (cond-eval env exp)
	(if (or (equal? 'else (caadr exp)) (cdr (base-eval env (caadr exp))))
		(cons env (last (map-base-eval env (cdadr exp))))
		(cond-eval env (cons 'cond (cddr exp)))
	)
)

(define (quote-eval env exp)
	(if (correct-syntax? 'quote exp)
		(cons env (cadr exp))
		(eval-error env 'syntax-error exp)
	)
)

(define (list-eval env exp)
	(map-base-eval env (cdr exp))
)

(define (begin-eval env exp)
	(let* ((res (map-base-eval (cdr exp) env))
		(env (car res))
			(vl (reverse (cdr res))))
		(cons env (if (null? vl) #t (car vl))))
)

(define (reverse l)
	(define (reverse-helper l acc)
		(if (null? l)
			acc
			(reverse-helper (cdr l) (cons (car l) acc))))
		(reverse-helper l '()
	)
)

;; function to assign primitive function data to function names
(define (make-top-env)
	(let* ((env (make-env))
		(env (define-var env '= (make-primitive 2 (lambda (env args) (cons env (= (car args) (cadr args)))))))
		(env (define-var env '+ (make-primitive 2 (lambda (env args) (cons env (+ (car args) (cadr args)))))))
		(env (define-var env '- (make-primitive 2 (lambda (env args) (cons env (- (car args) (cadr args)))))))
		(env (define-var env '* (make-primitive 2 (lambda (env args) (cons env (* (car args) (cadr args)))))))
		(env (define-var env '< (make-primitive 2 (lambda (env args) (cons env (< (car args) (cadr args)))))))
		(env (define-var env '> (make-primitive 2 (lambda (env args) (cons env (> (car args) (cadr args)))))))
		(env (define-var env 'assoc (make-primitive 2 (lambda (env args) (cons env (assoc (car args) (cadr args)))))))
		(env (define-var env 'cons (make-primitive 2 (lambda (env args) (cons env (cons (car args) (cadr args)))))))
		(env (define-var env 'car (make-primitive 1 (lambda (env args) (cons env (car (car args)))))))
		(env (define-var env 'cadr (make-primitive 1 (lambda (env args) (cons env (cadr (car args)))))))
		(env (define-var env 'caddr (make-primitive 1 (lambda (env args) (cons env (caddr (car args)))))))
		(env (define-var env 'cadddr (make-primitive 1 (lambda (env args) (cons env (cadddr (car args)))))))
		(env (define-var env 'cadadr (make-primitive 1 (lambda (env args) (cons env (cadadr (car args)))))))
		(env (define-var env 'cdr (make-primitive 1 (lambda (env args) (cons env (cdr (car args)))))))
		(env (define-var env 'cddr (make-primitive 1 (lambda (env args) (cons env (cddr (car args)))))))
		(env (define-var env 'cdddr (make-primitive 1 (lambda (env args) (cons env (cdddr (car args)))))))
		(env (define-var env 'cdadr (make-primitive 1 (lambda (env args) (cons env (cdadr (car args)))))))
		(env (define-var env 'list (make-primitive #f (lambda (env args) (cons env args)))))
		(env (define-var env 'null? (make-primitive 1 (lambda (env args) (cons env (null? (car args)))))))
		(env (define-var env 'pair? (make-primitive 1 (lambda (env args) (cons env (pair? (car args)))))))
		(env (define-var env 'number? (make-primitive 1 (lambda (env args) (cons env (number? (car args)))))))
		(env (define-var env 'boolean? (make-primitive 1 (lambda (env args) (cons env (boolean? (car args)))))))
		(env (define-var env 'string? (make-primitive 1 (lambda (env args) (cons env (string? (car args)))))))
		(env (define-var env 'eof-object? (make-primitive 1 (lambda (env args) (cons env (eof-object? (car args)))))))
		(env (define-var env 'symbol? (make-primitive 1 (lambda (env args) (cons env (symbol? (car args)))))))
		(env (define-var env 'equal? (make-primitive 2 (lambda (env args) (cons env (equal? (car args) (cadr args)))))))
		(env (define-var env 'and (make-primitive 2 (lambda (env args) (cons env (and (car args) (cadr args)))))))
		(env (define-var env 'or (make-primitive 2 (lambda (env args) (cons env (or (car args) (cadr args)))))))
		(env (define-var env 'not (make-primitive 1 (lambda (env args) (cons env (not (car args)))))))
		(env (define-var env 'set-car! (make-primitive 2 (lambda (env args) (cons env (set-car! (car args) (cadr args)))))))
		(env (define-var env 'write (make-primitive 1 (lambda (env args) (cons env (write (car args)))))))
		(env (define-var env 'read (make-primitive 1 (lambda (env args) (cons env (read (car args)))))))
		(env (define-var env 'open-input-file (make-primitive 1 (lambda (env args) (cons env (open-input-file (car args)))))))
		(env (define-var env 'close-input-port (make-primitive 1 (lambda (env args) (cons env (close-input-port (car args)))))))
		(env (define-var env 'newline (make-primitive 0 (lambda (env args) (newline) (cons env '*unspecified*)))))
		(env (define-var env 'display (make-primitive 1 (lambda (env args) (display (car args)) (cons env '*unspecified*)))))
		(env (car (base-eval env '(define map (lambda (f l) (if (null? l) l (cons (f (car l)) (map f (cdr l)))))))))
		; (env (define-var env 'load (make-primitive 1 (lambda (env args) (call-with-input-file (car args) (lambda (port) (define (re-loop env) (let* ((res (base-eval env (read port))) (env (car res)) (val (cdr res))) (if (equal? val '*exit*) (cons env '*unspecified*) (re-loop env)))) (re-loop env))))))))
		(env (define-var env 'load
			(make-primitive 1 (lambda (env args)
				(let* ((file-name (car args)) (port (open-input-file file-name)))
				(let loop ()
					(let* ((res (base-eval env (read port)))
						(env (car res))
						(val (cdr res)))
						(if (equal? val '*exit*)
							(begin
								(close-input-port port)
								(cons env '*unspecified*))
							(loop)
						))
				)
			))
		))))
	env)
)
